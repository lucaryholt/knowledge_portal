<p>JavaScript runtime built on <a target="_blank" href="https://v8.dev/">Chrome's V8 Javascript engine</a>.</p>

<hr>

<h4>General</h4>
<p>
    You used to only be able to run JavaScript in the browser, making JavaScript an almost only front-end language. <br>
    Node.JS changed that by enabling people to run JavaScript directly on the their machine through V8. <br>
    Now JavaScript can be used to make full-stack applications.
</p>

<hr>

<h4>npm</h4>
<p>
    npm is short for Node Package Manager and is a package manager for node. <br>
    There are other package managers for node,
    like <a target="_blank" href="https://yarnpkg.com/">yarn</a>, but npm is the largest and most used.
</p>
<p>
    npm consists of different parts, the ones we use the most are: the website and the CLI tool. <br>
    The website is mostly used to lookup npm packages and find documentation. <br>
    The CLI tool is used to actually install packages. <br>
</p>
<p>
    To install npm packages you need to have a <code>package.json</code> file (see following section). <br>
    Then you can run <code>npm install express</code> to install the 'express' package (and any package this depends on).
    <br>
    These packages will be placed in a folder called <code>node_modules</code>.
    This folder can get quite big and it is recommended you add it to <code>.gitignore</code>.
</p>
<p>
    The above install command (<code>npm install</code>) install the package in the <code>node_modules</code> folder
    and if you want to use that package (in the terminal) you have to point to the specific file. <br>
    But if want to be able to use an package in any project/directory without calling the specific file,
    you can use the <code>-g</code> flag. <br>
    As an example there is the <code>nodemon</code> package. A tool that automatically restarts the node application,
    when it detects an file change. Installing that by running <code>npm install -g nodemon</code>
    insures that you can use it in every project and without pointing to specific nodemon file.
</p>

<hr>

<h4>Noteworthy npm modules</h4>
<p>
    A couple of noteworthy npm modules are (more will be added):
    <ul>
        <li>cross-env</li>
        <li>budo</li>
        <li>nodemon</li>
    </ul>
</p>
<p>
    The <code>cross-env</code> module handles environmental variables and makes cross-platform uniformity possible. <br>
    As an example this project can take an <code>PORT</code> environmental variable and change the port on which the server
    listens for requests (see section about scripts under). <br>
    To access an environmental variable in code, if you for example wanted to read the <code>PORT</code> variable, you would
    write: <code>process.env.PORT</code>. <code>process</code> is built into Node and provides various information about the
    current running node process. <code>env</code> contains all environmental variables and <code>PORT</code> is what we called
    the variable when running the app. If we look for a variable in code, but do not declare it when running the app, it will result
    in <code>undefined</code>.
</p>
<p>
    <code>budo</code> is a module that provides a webserver with live reloading, useful when writing HTML, CSS + JS.
    <br>
    It is commonly installed as a global package (like <code>nodemon</code> above).
</p>

<hr>

<h4>package.json</h4>
<p>
    This JSON file is the file that tells NPM which packages and what versions to install (among other things). <br>
</p>
<p>
    Syntax: <br>
    <div class="code-block rounded">
        <code>
            { <br>
            &nbsp;&nbsp;&nbsp;&nbsp;"dependencies" : { <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"express" : "^4.17.1", <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ejs": "^3.1.5" <br>
            &nbsp;&nbsp;&nbsp;&nbsp;} <br>
            }
        </code> <br>
    </div>
    The file is built as an JSON object, where the key we use here <code>"dependencies"</code>
    refers to a list of KeyValuePairs noting the package and version number:
    the key being the package name and value being the version number
    (you can find both of these information on the packages npm page).
</p>
<p>
    When you run <code>npm install *package*</code>, that package gets added to the <code>package.json</code> file. <br>
    This makes it easy to share a project (via git for example), as you don't need to share the <code>node_modules</code> folder,
    but just the js files and package.json. Then another developer (or whomever) can clone the project,
    run <code>npm install</code> and then run the app.
</p>
<p>
    Another functionality we can define in <code>package.json</code> is <code>scripts</code>. <br>
    Scripts make it possibly to define commands (typically) for running the app in various environments. <br>
    This could make it easy for developers and end users to use the same project, without worrying about <br>
    changing the variables needed in development or production.
</p>
<p>
    An example of this can be seen here: <br>
    <div class="code-block rounded">
        <code>
            "scripts": { <br>
            &nbsp;&nbsp;&nbsp;&nbsp;"start-dev": "cross-env PORT=8080 nodemon app.js", <br>
            &nbsp;&nbsp;&nbsp;&nbsp;"start-prod": "node app.js" <br>
            }
        </code> <br>
    </div>
    In these lines of JSON we define two different scripts: <code>start-dev</code> and <code>start-prod</code>. <br>
    The <code>start-dev</code> script uses the two npm modules <code>cross-env</code> and <code>nodemon</code>,
    to provide a development port number and to continuously restart the app when changes have been made. <br>
    The <code>start-prod</code> script simply uses node to launch the app, as we have set a default port in the app
    and we don't want to restart the app on changes when it is in production.
</p>
<p>
    To run a script, you need to be in the same directory as <code>package.json</code> and then run <code>npm run start-dev</code>.
</p>

<hr>

<h4>REPL</h4>
<p>
    REPL: Read Evaluate Print Loop <br>
    REPL is a programming language environment, that takes a single expression and prints the result. <br>
</p>
<p>
    When Node.JS is installed on a computer you can run <code>node app.js</code> to run a JS file called app.js. <br>
    If you omit the name and just run <code>node</code> you enter the REPL. <br>
    This is the same as using the JavaScript console available in most browsers.
</p>
<p>
    In the REPL you can instantiate variables, functions and object. You can use different methods and see the results.
    <br>
    It can be used as a quick way to test things out in JavaScript.
</p>

<hr>

<h4>require()</h4>
<p>
    <code>require()</code> is a way in Node.JS to include modules from separate files. <br>
    This includes built in Node.JS modules, third-party modules (from fx <code>npm</code> or <code>yarn</code>) or
    JS scripts you have written yourself.
</p>
<p>
    The syntax to import a Node.JS, third-party and self written module is as follows in that order: <br>
    <div class="code-block rounded">
        <code>
            const fs = require('fs');
        </code> <br>
    </div>
    <div class="code-block rounded">
        <code>
            const express = require('express');
        </code> <br>
    </div>
    <div class="code-block rounded">
        <code>
            const selfWrittenModule = ('./path/to/script');
        </code> <br>
    </div>
</p>
