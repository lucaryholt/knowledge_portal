<div class="text-section sub-title">
    A block of code designed to perform a particular task
</div>

<hr>

<h4>General</h4>
<div class="text-section">
    Functions are first class citizens in <code>JS</code>. You can pass functions as parameters or save them as variables.
</div>

<hr>

<h4>Syntax</h4>
<div class="text-section">
    To define a method the basic syntax is:
    <pre><code class="code-block javascript rounded">
    function helloWorld(){
        console.log('Hello world');
    }
    </code></pre>
    To define a anonymous function as a variable:
    <pre><code class="code-block javascript rounded">
    const helloWorld = function (){
        console.log('Hello world');
    }
    </code></pre>
    Another quicker way to define a function is the <code>arrow syntax</code>:
    <pre><code class="code-block javascript rounded">
    const helloWorld = () => {
        console.log('Hello world');
    }
    </code></pre>
</div>
<div class="text-section">
  To have a function return a value, you type in <code>return</code> and then the value:
    <pre><code class="code-block javascript rounded">
    function multiplyBy2(number){
        return number * 2;
    }
    </code></pre>
</div>

<hr>

<h4>Anonymous functions</h4>
<div class="text-section">
    An anonymous function is a function declared without a name. When a function is declared without a name, it is not
    loaded in the memory at all times, allowing it to be called at any time. It is loaded when the code is run. That could be
    when it is declared like a variable or passed as parameter to another function.
</div>
<div class="text-section">
    To declare an anonymous function we can do it by referencing it from a variable:
    <pre><code class="code-block javascript rounded">
    const anon-function = function () {
        console.log('I am an anonymous functions');
    }
    </code></pre>
    We could then call the function by using the variable name and <code>()</code>:
    <pre><code class="code-block javascript rounded">
    anon-function();
    </code></pre>
</div>
<div class="text-section">
    You can also define an anonymous function with the <code>arrow syntax</code>.
</div>

<hr>

<h4>Passing a function</h4>
<div class="text-section">
    Functions can be passed like a variable. To pass a function you simply write it without the parentheses:
    <pre><code class="code-block javascript rounded">
    executeOtherFunction(helloWorld);

    function executeOtherFunction(function){
        function();
    }
    </code></pre>
    This would pass the <code>helloWorld</code> function and then the <code>executeOtherFunction</code> function
    would execute it, resulting in <code>Hello World</code> being printet to the console.
</div>

<hr>

<h4>Callbacks</h4>
<div class="text-section">
    Callbacks make it easy to perform actions asynchronous.
</div>
<div class="text-section">
    Syntax:
    <pre><code class="code-block javascript rounded">
    const poke = (name) => "poke " + name;
    function interact(name, interactingFunction){
        console.log(interactingFunction(name));
    }
    </code></pre>
    You could then call this:
    <pre><code class="code-block javascript rounded">
    interact("Bob", poke);
    </code></pre>
    This would print <code>poke Bob</code>. <br>
    But you could also define another function when calling <code>interact</code>:
    <pre><code class="code-block javascript rounded">
    interact("Jens", (name) => "hug " + name);
    </code></pre>
    Which would print <code>hug Jens</code>.
</div>
<div class="text-section">
    Callbacks are used a lot in frameworks like Express for error, request and response handling.
</div>

<hr>

<h4>Lambda</h4>
<div class="text-section">
    Lambda expressions are not functions, but I choose to mention them here as they are expressions that create
    functions. <br>
    This is very important in <code>JS</code>, where functions are first-class citizens
    and are passed as arguments to other functions etc.
</div>
<div class="text-section">
    To make an lambda expression (and create a function) we use the arrow notation from before.
</div>

<hr>

<h4>Ternary</h4>
<div class="text-section">
    The <code>ternary</code> conditional operator is not a function either (like lambda expressions),
    but I felt this was the best place to mention it.
</div>
<div class="text-section">
    It can be compared to a quick way of writing a <code>for else</code> with return values. <br>
    You set a condition and return one value if true and another if false.
</div>
<div class="text-section">
    Syntax:
    <pre><code class="code-block javascript rounded">
    const umbrellaMessage = isRaining ? 'Bring it!' : 'Nah, leave it.';
    </code></pre>
    The above expression evaluates if <code>isRaining</code> is true or false and returns one of the two strings.
</div>

<hr>

<h4>Global functions</h4>
<div class="text-section">
    <code>JS</code> has a number of global functions
    (a list can be found in the link: 'W3 Schools - JavaScript Global Reference').
    I will mention a few of them here.
</div>
<div class="text-section">
    <code>Number()</code> is a function that converts an objects value to a number.
    An identical function exists for strings: <code>String()</code>. <br>
    Similarly functions exist to parse a string to floating point number and integer, <code>parseFloat()</code>
    and <code>parseInt()</code>.
</div>
<div class="text-section">
    Global functions can be called from anywhere in <code>JS</code>.
</div>

<hr>

<h4>filter(), find() & map()</h4>
<div class="text-section">
    The <code>filter()</code>, <code>find()</code> and <code>map()</code> functions are array functions.
</div>
<h5>filter()</h5>
<div class="text-section">
    <code>filter()</code> returns an array filled with elements that pass a test. This test is provided to
    <code>filter()</code> as a function. It calls said function once for each element in the array. Example:
    <pre><code class="code-block javascript rounded">
    const ages = [32, 33, 16, 40];
    function checkAdult(age) {
        return age >= 18;
    }
    const adults = ages.filter(checkAdult);
    </code></pre>
    In the above code we have an array of ages, then a function that returns true if age is equal or greater than 18.
    Then we instantiate an adults constant with the value, from <code>filter()</code> called on the ages array,
    with <code>checkAdult(age)</code> as parameter. <br>
    The above code can be written shorter using an lambda expression:
    <pre><code class="code-block javascript rounded">
    const ages = [32, 33, 16, 40];
    const adults = ages.filter(age => {
        return age >= 18;
    });
    </code></pre>
</div>
<div class="text-section">
    <code>filter()</code> does not change the original array, but returns a new array. <br>
    <code>filter()</code> does not run the test for elements without value.
</div>
<h5>find()</h5>
<div class="text-section">
    Like <code>filter()</code>, <code>find()</code> checks elements in an array with a test provided by a function.
    Unlike <code>filter()</code> it only returns the first value it finds.
    It it written in the exact same way ('find' instead of 'filter').
</div>
<div class="text-section">
    <code>find()</code> does not change the original array. <br>
    If it does not find a value, that passes the test, it returns <code>undefined</code>.
</div>

<h5>map()</h5>
<div class="text-section">
    <code>map()</code> also creates a new array based on a function, but unlike <code>filter()</code>
    and <code>find()</code>, the elements do not need to pass a test. <code>map()</code> runs the function
    for each element and returns the value. <br>
    It is written in the same way as <code>filter()</code> and <code>find()</code>.
</div>
<div class="text-section">
    <code>map()</code> does not run the function for elements without values. <br>
    <code>map()</code> does not change the original array.
</div>